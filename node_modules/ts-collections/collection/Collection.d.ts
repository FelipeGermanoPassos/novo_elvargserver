import { ICollection, IEachFunction } from './ICollection';
import { IPredicate, IPredicateFunction } from '../predicate/IPredicate';
import { IMapper } from '../mapper/IMapper';
import { IComparator } from '../comparator/IComparator';
export declare const INITIAL_CAPACITY: number;
export declare const CAPACITY_GROW_FACTOR: number;
export declare abstract class AbstractCollection<TItem> implements ICollection<TItem> {
    private currentCapacity;
    /**
     * Lodash compatibility
     * @override
     */
    length: number;
    /**
     * Lodash compatibility
     * @override
     */
    [index: number]: TItem;
    /**
     * ES6 iterators compatibility
     * @override
     */
    [Symbol.iterator]: () => Iterator<TItem>;
    /**
     * @override
     */
    iterator(): () => Iterator<TItem>;
    /**
     * @override
     */
    insert(position: number, item: TItem): ICollection<TItem>;
    /**
     * @override
     */
    addArray(items: Array<TItem>): ICollection<TItem>;
    protected checkAndGrowUp(): void;
    abstract getIteratorInstance(): Iterator<TItem>;
    abstract addAll(items: ICollection<TItem>): ICollection<TItem>;
    abstract get(index: number): TItem;
    abstract add(item: TItem): ICollection<TItem>;
    abstract getSize(): number;
    abstract remove(item: TItem): boolean;
    abstract removeAll(): ICollection<TItem>;
    abstract sort(comparator: IComparator<TItem>): ICollection<TItem>;
    /**
     * Compatible with an array
     */
    abstract filter(predicate: IPredicate<TItem> | IPredicateFunction<TItem>): ICollection<TItem>;
    abstract iterate(callback: IEachFunction<TItem>, predicate?: IPredicate<TItem>): any;
    abstract map<E>(mapper: IMapper<TItem, E>): Array<E>;
    abstract toArray(): Array<TItem>;
    /**
     * Compatible with an array
     */
    abstract find(predicate: IPredicate<TItem> | IPredicateFunction<TItem>): TItem;
    /**
     * Compatible with an array
     */
    abstract forEach(callback: IEachFunction<TItem>): any;
    abstract isEmpty(): boolean;
}
export declare abstract class Collection<TItem> extends AbstractCollection<TItem> {
    constructor();
    /**
     * @override
     */
    iterate(callback: IEachFunction<TItem>, predicate?: IPredicate<TItem> | IPredicateFunction<TItem>): void;
    /**
     * Compatible with an array
     */
    forEach(callback: IEachFunction<TItem>): void;
    /**
     * @override
     */
    addAll(items: ICollection<TItem>): ICollection<TItem>;
    /**
     * Compatible with an array
     * @override
     */
    filter(predicate: IPredicate<TItem> | IPredicateFunction<TItem>): ICollection<TItem>;
    /**
     * @override
     */
    map<E>(mapper: IMapper<TItem, E>): Array<E>;
    /**
     * @override
     */
    toArray(): Array<TItem>;
    /**
     * @override
     */
    addArray(items: Array<TItem>): ICollection<TItem>;
    /**
     * Compatible with an array
     * @override
     */
    find(predicate: IPredicate<TItem> | IPredicateFunction<TItem>): TItem;
    /**
     * @override
     */
    isEmpty(): boolean;
    /**
     * @override
     */
    readonly length: number;
    protected newInstance(): ICollection<TItem>;
    private isSuitable(value, predicate);
}
