"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HashSet = void 0;
const util = require("util");
const rxjs_1 = require("rxjs");
class HashSet extends Set {
    static of(items) {
        return new HashSet(items);
    }
    static empty() {
        return new HashSet([]);
    }
    constructor(set) {
        super(set);
    }
    intersection(b) {
        return this.filter((x) => b.has(x));
    }
    difference(b) {
        return this.filter((x) => !b.has(x));
    }
    union(b) {
        return new HashSet([...this, ...b]);
    }
    symmetricDifference(b) {
        return this.difference(b).union(b.difference(this));
    }
    isSubsetOf(b) {
        for (const item of this) {
            if (!b.has(item)) {
                return false;
            }
        }
        return true;
    }
    isSupersetOf(b) {
        return !this.isSubsetOf(b);
    }
    isProperSubsetOf(b) {
        return this.isSubsetOf(b) && !this.equals(b);
    }
    isProperSupersetOf(b) {
        return this.isSupersetOf(b) && !this.equals(b);
    }
    some(fn) {
        let index = 0;
        for (const item of this) {
            if (fn(item, index)) {
                return true;
            }
            index++;
        }
        return false;
    }
    every(fn) {
        let index = 0;
        for (const item of this) {
            if (!fn(item, index)) {
                return false;
            }
            index++;
        }
        return true;
    }
    find(fn) {
        let index = 0;
        for (const item of this) {
            if (fn(item, index)) {
                return item;
            }
            index++;
        }
    }
    map(fn) {
        const result = HashSet.empty();
        let index = 0;
        for (const item of this) {
            result.add(fn(item, index));
            index++;
        }
        return result;
    }
    flatMap(fn) {
        const result = HashSet.empty();
        let index = 0;
        for (const item of this) {
            for (const mappedItem of fn(item, index)) {
                result.add(mappedItem);
            }
            index++;
        }
        return result;
    }
    filter(fn) {
        const result = HashSet.empty();
        let index = 0;
        for (const item of this) {
            if (fn(item, index)) {
                result.add(item);
            }
            index++;
        }
        return result;
    }
    reduce(fn, initial) {
        let acc = initial;
        let index = 0;
        for (const item of this) {
            acc = fn(acc, item, index);
            index++;
        }
        return acc;
    }
    partition(fn) {
        const result = [HashSet.empty(), HashSet.empty()];
        let index = 0;
        for (const item of this) {
            if (fn(item, index)) {
                result[0].add(item);
            }
            else {
                result[1].add(item);
            }
            index++;
        }
        return result;
    }
    equals(other) {
        if (this.size !== other.size) {
            return false;
        }
        for (const item of this) {
            if (!other.has(item)) {
                return false;
            }
        }
        return true;
    }
    isEmpty() {
        return this.size === 0;
    }
    toString() {
        return `Collections.Set(${this.toArray().toString()})`;
    }
    toArray() {
        return Array.from(this);
    }
    toJsSet() {
        return new Set([...this]);
    }
    toObservable() {
        return (0, rxjs_1.from)(this);
    }
    [Symbol.for('nodejs.util.inspect.custom')]() {
        return util.inspect(this.toArray(), {
            depth: null,
            colors: true,
            showHidden: false,
        });
    }
}
exports.HashSet = HashSet;
//# sourceMappingURL=hash-set.js.map